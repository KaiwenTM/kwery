The mapper module builds on core to provide typical DAO (Data Access Object) functionality.

#### Mapping 

As Kwery believes your domain model shouldn't be tainted by mapping annotations,
it uses a `Table` object to define the mapping between rows and classes.

Given the following SQL table:
 
```SQL
create sequence actor_seq;
create table actor (
    actor_id integer generated by default as sequence actor_seq primary key,
    first_name character varying(255) not null,
    last_name character varying(255) null,
    last_update timestamp not null
);
```

The following will map the table to and from the defined `Name` and `Actor` classes.

Note that the mapping doesn't have to be flat - here we're combining the first and
last names into their own class.

```kotlin
// We'll map to standard immutable classes
class Name(val firstName: String, val lastName: String)
class Actor(val id: Int, val name: Name, val lastUpdate: LocalDateTime)

// Table configuration defines defaults, converters and naming conventions
// In this case, it includes converters for LocalDateTime <-> java.sql.Timestamp
val tableConfig = TableConfiguration(defaults, converters, camelToLowerUnderscore)

// A table object defines the mapping between columns and models
// Conversions default to those defined in the configuration but may be overridden
object actorTable : Table<Actor, Int>("actor", tableConfig), VersionedWithTimestamp {
    val ActorId    by col(Actor::id,                     id = true)
    val FirstName  by col(Name::firstName, { it.name },  notNull = true)
    val LastName   by col(Name::lastName,  { it.name },  notNull = true)
    val LastUpdate by col(Actor::lastUpdate,             version = true)

    override fun idColumns(id: Int) = setOf(ActorId of id)

    override fun create(value: Value<Actor>) = Actor(value of ActorId,
            Name(value of FirstName, value of LastName), value of LastUpdate)
}
```

#### Data Access Objects (DAOs) 

Continuing the example from above a single line let's us use the `Table` definition to
create a DAO will all the standard CRUD operations.

```kotlin
class ActorDao(session: Session) : AbstractDao<Actor, Int>(session, actorTable, { it.id })

// Now we can use the DAO
val dao = ActorDao(session)
val inserted = dao.insert(Actor(1, Name("Kate", "Beckinsale"), LocalDateTime.now())
val actors = dao.findAll()
```
