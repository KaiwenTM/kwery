The mapper module builds on core to provide typical DAO (Data Access Object) functionality.

#### Mapping 

As Kwery believes your domain model shouldn't be tainted by mapping annotations,
it uses a `Table` object to define the mapping between rows and classes.

Given the following SQL table:
 
```SQL
create sequence actor_seq;
create table actor (
    actor_id    integer generated by default as sequence actor_seq primary key,
    first_name  character varying(255) not null,
    last_name   character varying(255) not null,
    last_update timestamp              not null
);
```

The following will map the table to and from the defined `Name` and `Actor` classes.

Note that the mapping doesn't have to be flat - here we're combining the first and
last names into their own class.

```kotlin
// We'll map to standard immutable classes
class Name(val firstName: String, val lastName: String)
class Actor(val id: Int, val name: Name, val lastUpdate: LocalDateTime)

// Table configuration defines defaults, converters and naming conventions
// In this case, it includes converters for LocalDateTime <-> java.sql.Timestamp
val tableConfig = TableConfiguration(defaults, converters, camelToLowerUnderscore)

// A table object defines the mapping between columns and models
// Conversions default to those defined in the configuration but may be overridden
object actorTable : Table<Actor, Int>("actor", tableConfig), VersionedWithTimestamp {
    val ActorId    by col(Actor::id, id = true)
    val FirstName  by col(Name::firstName, { it.name })
    val LastName   by col(Name::lastName,  { it.name })
    val LastUpdate by col(Actor::lastUpdate, version = true)

    override fun idColumns(id: Int) = setOf(ActorId of id)

    override fun create(value: Value<Actor>) = Actor(value of ActorId,
            Name(value of FirstName, value of LastName), value of LastUpdate)
}
```

Each column in a table should have a corresponding `val` defined in the table object.

The name of the `val` should match the name of the column after the naming convention
is applied.

So in the example above, `val ActorId` matches the `actor_id` column as we are
using the `camelToLowerUnderscore` naming convention.

`idColumns` must be overridden to define how to apply the primary key to an object.

The `create` function essentially allows row to be converted into an object
in a type safe manner.

A row does not have to be mapped to a flat structure. In the example above,
the first and last names are combined into a `Name` class.

To achieve this you must:

1. Use the overloaded variant of `col` that accepts a `property` (`Name::firstname`) and
 a `path` (`{ it.name }`). The `path` arguments defines how fetch the `Name` object
 given an `Actor` object in example above.

2. Ensure your `create` function creates the appropriate nested structure (in this
 case it constructs a `Name` object from the `FirstName` and `LastName` values).

Finally, a `Column` object can be added directly if explicit control over mapping
is required.


#### Data Access Objects (DAOs) 

Continuing the example from above a single line let's us use the `Table` definition to
create a DAO will all the standard CRUD operations.

```kotlin
class ActorDao(session: Session) : AbstractDao<Actor, Int>(session, actorTable, { it.id })

// Now we can use the DAO
val dao = ActorDao(session)
val inserted = dao.insert(Actor(1, Name("Kate", "Beckinsale"), LocalDateTime.now())
val actors = dao.findAll()
```
