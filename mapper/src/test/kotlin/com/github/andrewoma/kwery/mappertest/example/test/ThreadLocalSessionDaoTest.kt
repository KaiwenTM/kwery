/*
 * Copyright (c) 2016 Andrew O'Malley
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.github.andrewoma.kwery.mappertest.example.test

import com.github.andrewoma.kwery.core.Session
import com.github.andrewoma.kwery.core.ThreadLocalSession
import com.github.andrewoma.kwery.core.dialect.HsqlDialect
import com.github.andrewoma.kwery.core.interceptor.LoggingInterceptor
import com.github.andrewoma.kwery.mapper.AbstractDao
import com.github.andrewoma.kwery.mapper.Table
import com.github.andrewoma.kwery.mapper.Value
import com.github.andrewoma.kwery.mapper.VersionedWithInt
import com.github.andrewoma.kwery.mappertest.example.tableConfig
import com.github.andrewoma.kwery.mappertest.testDataSource
import org.junit.Before
import org.junit.Test
import kotlin.test.assertEquals

class ThreadLocalSessionFilmDaoTest {
    val session = ThreadLocalSession(testDataSource, HsqlDialect(), interceptor = LoggingInterceptor())
    val dao = FooDao(session)

    @Before
    fun before() {
        with(session) {
            update("create sequence foo_seq")
            update("""create table foo(
              id integer generated by default as sequence foo_seq primary key,
              name varchar(1000),
              version integer
            )""")
        }
    }

    @Test fun `should support all dao functions with ThreadLocalSession`() {
        val foo1 = Foo(1, "foo1")
        val foo2 = Foo(2, "foo2")
        assertEquals(foo1, dao.insert(foo1))
        assertEquals(foo2, dao.insert(foo2))

        assertEquals(foo1, dao.findById(1))
        assertEquals(foo1, dao.findByIdForUpdate(1))
        assertEquals(setOf(foo1, foo2), dao.findByIds(setOf(1, 2)).values.toSet())
        assertEquals(listOf(foo1, foo2), dao.findAll())
        assertEquals(listOf(foo1), dao.findByExample(Foo(1, "foo1"), setOf(fooTable.Name)))

        val updated = foo1.copy(name = "foo1u", version = 2)
        assertEquals(updated, dao.update(foo1, updated))
        assertEquals(updated, dao.findById(1))

        assertEquals(foo1, dao.unsafeUpdate(foo1))
        assertEquals(foo1, dao.findById(1))

        val ubu1 = foo1.copy(name = "ubu1")
        val ubu2 = foo2.copy(name = "ubu2")
        dao.unsafeBatchUpdate(listOf(ubu1, ubu2))
        assertEquals(listOf(ubu1, ubu2), dao.findAll())

        val bu1 = foo1.copy(name = "bu1", version = 2)
        val bu2 = foo2.copy(name = "bu2", version = 2)
        dao.batchUpdate(listOf(ubu1 to bu1, ubu2 to bu2))
        assertEquals(listOf(bu1, bu2), dao.findAll())

        val bi1 = Foo(3, "foo3")
        val bi2 = Foo(4, "foo4")
        dao.batchInsert(listOf(bi1, bi2))
        assertEquals(listOf(bu1, bu2, bi1, bi2), dao.findAll())

        dao.delete(bu1.id)
        assertEquals(listOf(bu2, bi1, bi2), dao.findAll())

        assertEquals(listOf(0, 1, 2, 3, 4), dao.allocateIds(5))
    }

    data class Foo(val id: Int, val name: String, val version: Int = 1)

    object fooTable : Table<Foo, Int>("foo", tableConfig, sequence = "foo_seq"), VersionedWithInt {
        val Id   by col(Foo::id, id = true)
        val Name by col(Foo::name)
        val Version by col(Foo::version, version = true)
        override fun idColumns(id: Int) = setOf(Id of id)
        override fun create(value: Value<Foo>): Foo = Foo(value of Id, value of Name, value of Version)
    }

    class FooDao(session: Session) : AbstractDao<Foo, Int>(session, fooTable, { it.id }, "int")
}